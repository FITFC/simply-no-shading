apply from: 'versionCatalog.gradle'

ext {
	semversions = [:]

	coerceMavenVersionRange = { String range ->
		final def delimiter = range.indexOf ','

		if (delimiter == -1) return '';

		final def joiner = new StringJoiner(' ')
		final def lowerBound = range[1 ..< delimiter]
		final def upperBound = reduce range, delimiter + 1, 1
		
		switch (lowerBound ? range[0] : ' ') {
		case '[': joiner.add ">=${lowerBound}"; break
		case '(': case ']': joiner.add ">${lowerBound}"; break
		}

		switch (upperBound ? range[range.length() - 1] : ' ') {
		case ']': joiner.add "<=${upperBound}"; break
		case ')': case '[': joiner.add "<${upperBound}"; break
		}

		return joiner as String
	}

	coerceVersionRange = { String range ->
		if (range.endsWith('.+'))
			return "${reduce range, 0, 2}.x"
		else
			return coerceMavenVersionRange(range) ?: range ?: '0'
	}

	minecraftTag = { prefix = '+mc' ->
		final def range = versionRanges.minecraft

		if (!range.endsWith('.+')) {
			final def delimiter = range.indexOf ','

			if (delimiter == -1) return range ? "$prefix$range" : ''

			final def joiner = new StringJoiner('-to-', prefix, '')
			final def lowerBound = range[1 ..< delimiter]
			final def upperBound = reduce range, delimiter + 1, 1

			switch (upperBound ? range[range.length() - 1] : '') {
			case '[': case '(': case ']': joiner.add upperBound
			}

			switch (lowerBound ? range[0] : '') {
			case '[': case '(': case ']': joiner.add lowerBound
			}

			return joiner.length() ? joiner.toString() : range ? "$prefix$range" : ''
		} else {
			return "$prefix${reduce range, 0, 2}.x"
		}
	}
}

defaultProperty 'modGroup', 'group'
defaultProperty 'modName', 'name'
defaultProperty 'modVersion', 'version'

versionCatalog.versionAliases.each {
	final def versionConstraint = versionCatalog.findVersion(it).get()
	final def versionRange = versionConstraint.requiredVersion

	traversed(semversions, it, coerceVersionRange(versionRange))
}

def defaultProperty(String modKey, String key) {
	if (project.properties[modKey] && isUnspecified(project[key])) {
		project[key] = project.properties[modKey]
	} else {
		project.properties[modKey] = project[key]
	}
}

def isUnspecified(String value) {
	return value == 'unspecified' || !value
}

def traversed(Map map, String alias, value) {
	final def keys = alias.split(/\P{Alnum}+/)

	if (keys.length == 0) return map

	for (i in 0 ..< keys.length - 1) {
		map = map.computeIfAbsent(keys[i], key -> [:])
	}

	map[keys[keys.length - 1]] = value

	return map
}
